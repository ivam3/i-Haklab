#!/bin/bash
#This file is part of i-Haklab command
IFS=$'\n\t'
trap ctrl_c 2
source $HOME/.local/etc/i-Haklab/variables
source $iHETC/functions

chk-pkg adb android-tools

airscope() {
    # AirScope: Wi-Fi radar for Android devices via ADB

    #==================================================
    # Define color escape codes
    #==================================================

    # Regular Colors
    RED='\033[0;31m'       # Red
    GREEN='\033[0;32m'     # Green
    YELLOW='\033[0;33m'    # Yellow
    BLUE='\033[0;34m'      # Blue
    CYAN='\033[0;36m'      # Cyan
    PURPLE='\033[0;35m'    # Purple
    WHITE='\033[0;37m'     # White
    RESET='\033[0m'        # Reset

    # Bold Colors
    REDB='\033[1;31m'      # Red
    GREENB='\033[1;32m'    # Green
    YELLOWB='\033[1;33m'   # Yellow
    BLUEB='\033[1;34m'     # Blue
    CYANB='\033[1;36m'     # Cyan
    PURPLEB='\033[1;35m'   # Purple
    WHITEB='\033[1;37m'    # White

    BLINK='\e[5m'	       # Blink

    # Array of color names
    allcolors=("RED" "GREEN" "YELLOW" "BLUE" "CYAN" "PURPLE" "WHITE")

    #==================================================
    # Function to print banner with a random color
    #==================================================
    ascii_banner() {
        random_color="${allcolors[$((RANDOM % ${#allcolors[@]}))]}"
        case $random_color in
            "RED") color_code=$RED ;;
            "GREEN") color_code=$GREEN ;;
            "YELLOW") color_code=$YELLOW ;;
            "BLUE") color_code=$BLUE ;;
            "CYAN") color_code=$CYAN ;;
            "PURPLE") color_code=$PURPLE ;;
            "WHITE") color_code=$WHITE ;;
        esac

        echo -e "${color_code}"
        cat << "EOF"
        _    _      ____                       
       / \  (_)_ __/ ___|  ___ ___  _ __   ___ 
      / _ \ | | '__\___ \ / __/ _ \| '_ \ / _ \
     / ___ \| | |   ___) | (_| (_) | |_) |  __/
    /_/   \_\_|_|  |____/ \___\___/| .__/ \___|
                                   |_|    
EOF
        echo -e "${RESET}"
    }

    #==================================================
    # Main Script
    #==================================================

    ascii_banner

    echo -e "                  "
    echo -e "${CYANB}------------------${RESET}"
    echo -e "${YELLOWB}Disabling Wi-Fi...${RESET}"
    adb shell svc wifi disable
    sleep 2
    echo -e "${GREENB}Enabling Wi-Fi...${RESET}"
    echo -e "${CYANB}------------------${RESET}"
    echo -e "                 "
    adb shell svc wifi enable
    sleep 5

    # Collect Wi-Fi scan results
    SCAN=$(adb shell dumpsys wifi | \
        grep "Networks filtered out due" | \
        sed 's/.*Networks filtered out due [^:]*: //' | \
        tr '/' '\n' | \
        grep -E '[0-9a-f]{2}(:[0-9a-f]{2}){5}' | \
        sed -E 's/([^:]+):([0-9a-f:]+)\(([^)]+)\)(-?[0-9]+)/\1,\2,\3,\4/' | \
        awk -F, 'NF==4 {print "SSID=" $1 ",BSSID=" $2 ",Band=" $3 ",RSSI=" $4 "dBm"}'
    )

    # Process, sort, and display results
    echo "$SCAN" | awk -F'[=,]' '
    function color_rssi(r) {
        if (r >= -70) return "\033[1;32m" r " dBm\033[0m"   # green
        if (r >= -85) return "\033[1;33m" r " dBm\033[0m"   # yellow
        return "\033[1;31m" r " dBm\033[0m"                 # red
    }
    {
        for(i=1;i<=NF;i++) gsub(/^ +| +$/, "", $i)
        ssid=$2; bssid=$4; band=$6; rssi=$8
        gsub(" dBm","",rssi)
        if (ssid=="" || bssid=="" || band=="" || rssi=="") next
        if (!(bssid in best) || rssi > best[bssid]) {
            best[bssid]=rssi
            data[bssid]=ssid "|" band "|" rssi "|" bssid
        }
    }
    END {
        print "\033[1;37m" sprintf("%-32s %-7s %-10s %s", "SSID", "BAND", "RSSI", "BSSID") "\033[0m"
        print "\033[1;37m--------------------------------------------------------------------------------\033[0m"
        for (b in data) print data[b]
    }' | sort -t'|' -k3 -n -r | awk -F"|" '
    function color_rssi(r){
        if (r ~ /^-?[0-9]+$/) {
            if (r >= -70) return "\033[1;32m" r " dBm\033[0m"
            if (r >= -85) return "\033[1;33m" r " dBm\033[0m"
            return "\033[1;31m" r " dBm\033[0m"
        } else {
            return r
        }
    }
    function color_bssid(b){ return "\033[1;35m" b "\033[0m" }  # Bright green BSSID
    NR==1 {print; next}  # print header as-is
    {
        printf "\033[1;37m%-32s %-7s %-10s %s\033[0m\n", $1, $2, color_rssi($3), color_bssid($4)
    }'
}


dumpsys() {
    # --- COLOR CODES ---
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color

    # --- USAGE ---
    # ./dump_adb.sh [device_serial]

    TARGET_DEVICE="$1"

    # --- PRE-CHECKS ---

    # Check if adb is installed
    if ! command -v adb &> /dev/null; then
        echo -e "${RED}ERROR: adb is not installed. Please install adb and try again.${NC}"
        exit 1
    fi

    # Start adb server if not running
    if ! adb get-state &> /dev/null; then
        echo -e "${BLUE}Starting adb server...${NC}"
        adb start-server
        sleep 1
    fi

    # Wait for a device to connect
    MAX_RETRIES=10
    SLEEP_INTERVAL=3
    DEVICE=""

    for ((i=1; i<=MAX_RETRIES; i++)); do
        if [ -n "$TARGET_DEVICE" ]; then
            DEVICE="$TARGET_DEVICE"
            STATE=$(adb -s "$DEVICE" get-state 2>/dev/null)
            if [ "$STATE" == "device" ]; then
                echo -e "${GREEN}Connected device: $DEVICE${NC}"
                break
            else
                echo -e "${BLUE}Device $DEVICE not available. Waiting... ($i/$MAX_RETRIES)${NC}"
            fi
        else
            DEVICE=$(adb devices | awk 'NR>1 && $2=="device" {print $1}')
            if [ -n "$DEVICE" ]; then
                echo -e "${GREEN}Connected device: $DEVICE${NC}"
                break
            else
                echo -e "${BLUE}No device connected. Waiting for device... ($i/$MAX_RETRIES)${NC}"
            fi
        fi
        sleep $SLEEP_INTERVAL
    done

    if [ -z "$DEVICE" ]; then
        echo -e "${RED}ERROR: No device connected after $((MAX_RETRIES * SLEEP_INTERVAL)) seconds. Exiting.${NC}"
        exit 1
    fi

    # --- SETUP OUTPUT DIRECTORY ---
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    OUTPUT_DIR="$PWD/DumpSysReport_$TIMESTAMP"
    mkdir -p "$OUTPUT_DIR"

    # Arrays to track successes and failures
    SUCCESS_CMDS=()
    FAILED_CMDS=()

    # Function to run a command, print description, and save output
    run_adb_command() {
        local index="$1"
        local total="$2"
        local cmd="$3"
        local desc="$4"
        local filename="$5"

        echo -e "${BLUE}========================================${NC}"
        echo -e "${BLUE}[$index/$total] $desc${NC}"
        echo -e "${BLUE}----------------------------------------${NC}"
        
        # Execute command on the selected device, save output
        if adb -s "$DEVICE" shell $cmd | tee "$OUTPUT_DIR/$filename"; then
            echo -e "${GREEN}[✔] $desc - Output saved to $OUTPUT_DIR/$filename${NC}"
            SUCCESS_CMDS+=("$desc")
        else
            echo -e "${RED}[✖] $desc - Command failed${NC}"
            FAILED_CMDS+=("$desc")
        fi
        echo
    }

    # List of commands and descriptions
    declare -a COMMANDS=(
        "dumpsys meminfo|Showing Memory Usage Statistics|meminfo.txt"
        "dumpsys media.audio_flinger|Extracting Audio Playback History|media_audio_flinger.txt"
        "dumpsys sensorservice|Displaying Motion and Environmental Sensor Activity|sensorservice.txt"
        "dumpsys adb|Providing ADB Connection Information|adb.txt"
        "dumpsys account|Listing User Accounts on the Device|account.txt"
        "dumpsys persona|Displaying Multi-User Profile Data|persona.txt"
        "dumpsys fingerprint|Extracting Fingerprint Authentication Data|fingerprint.txt"
        "dumpsys netstats|Showing Network Usage Statistics|netstats.txt"
        "dumpsys mount|Listing Mounted Storage Volumes|mount.txt"
        "dumpsys power|Providing Device Power Management Details|power.txt"
        "dumpsys dropbox|Listing System Crash Reports and Events|dropbox.txt"
        "dumpsys location|Displaying GPS and Location Service Activity|location.txt"
        "dumpsys notification|Showing Active and Dismissed Notifications|notification.txt"
        "dumpsys telecom|Extracting Call Logs and Telephony Data|telecom.txt"
        "dumpsys lock_settings|Providing Lock Screen Settings and Credentials|lock_settings.txt"
        "dumpsys package|Retrieving Installed Package Details|package.txt"
        "dumpsys wifi|Extracting WiFi Connection and History|wifi.txt"
        "dumpsys window|Listing Active Windows and Screen State|window.txt"
        "dumpsys stats|Retrieving System Performance Metrics|stats.txt"
        "dumpsys batterystats|Showing Battery Usage History|batterystats.txt"
        "dumpsys usb|Showing USB Connection History|usb.txt"
        "dumpsys clipboard|Showing Clipboard History|clipboard.txt"
    )

    # Total number of commands
    TOTAL=${#COMMANDS[@]}

    # Loop through commands
    for i in "${!COMMANDS[@]}"; do
        IFS="|" read -r cmd desc filename <<< "${COMMANDS[$i]}"
        run_adb_command $((i+1)) "$TOTAL" "$cmd" "$desc" "$filename"
    done

    # Print summary
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}SUMMARY OF EXECUTED COMMANDS${NC}"
    echo -e "${BLUE}========================================${NC}"

    echo -e "${GREEN}Succeeded Commands: ${#SUCCESS_CMDS[@]}${NC}"
    for cmd in "${SUCCESS_CMDS[@]}"; do
        echo -e "  ${GREEN}✔ $cmd${NC}"
    done

    echo
    echo -e "${RED}Failed Commands: ${#FAILED_CMDS[@]}${NC}"
    for cmd in "${FAILED_CMDS[@]}"; do
        echo -e "  ${RED}✖ $cmd${NC}"
    done

    echo
    echo -e "${BLUE}All outputs saved in $OUTPUT_DIR${NC}"
}


extract() {
    # ===============================================
    #   ADB Data Extraction & System Snapshot Script
    # ===============================================
    # Author: Douglas Habian 
    # Description:
    #   Executes multiple adb commands to extract
    #   diagnostic and user data from a connected
    #   Android device, saving all outputs neatly.
    # ===============================================

    # ---------- COLORS ----------
    RED="\033[0;31m"
    GREEN="\033[0;32m"
    YELLOW="\033[1;33m"
    BLUE="\033[0;34m"
    NC="\033[0m" # No Color

    SCRIPT_START=$(date +%s)

    # ---------- CHECK ADB ----------
    if ! command -v adb &> /dev/null; then
        echo -e "${RED}[ERROR] ADB is not installed. Please install Android Platform Tools.${NC}"
        exit 1
    fi

    # ---------- START ADB SERVER ----------
    adb start-server &> /dev/null

    # ---------- CHECK DEVICE CONNECTION ----------
    DEVICE=$(adb devices | awk 'NR==2 {print $1}')
    if [ -z "$DEVICE" ]; then
        echo -e "${RED}[ERROR] No device connected. Connect a device via USB and enable USB Debugging.${NC}"
        exit 1
    fi
    echo -e "${GREEN}[OK] Connected device: $DEVICE${NC}\n"

    # ---------- CREATE OUTPUT DIRECTORY ----------
    OUTPUT_DIR="$PWD/ADB_Report_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$OUTPUT_DIR"

    # ---------- FUNCTION TO RUN COMMAND ----------
    # Usage:
    #   run_adb_command "Description" "command" "filename" ["silent"]
    # If "silent" is passed as the 4th argument, output won't be printed to screen.
    run_adb_command() {
        DESCRIPTION=$1
        COMMAND=$2
        FILENAME=$3
        SILENT=$4

        echo -e "${BLUE}[*] ${DESCRIPTION}${NC}"

        if [ "$SILENT" = "silent" ]; then
            adb shell $COMMAND > "$OUTPUT_DIR/$FILENAME" 2>&1
        else
            adb shell $COMMAND | tee "$OUTPUT_DIR/$FILENAME"
        fi

        echo -e "${YELLOW}[+] Output saved to ${OUTPUT_DIR}/${FILENAME}${NC}\n"
    }

    # ---------- DEVICE INFO ----------
    run_adb_command "Gathering basic device information..." \
    "getprop | grep -E 'ro.product.model|ro.product.manufacturer|ro.build.version.release|ro.serialno'" \
    "device_info.txt"

    # ---------- DEVICE STATE SNAPSHOT (SILENT) ----------
    run_adb_command "Capturing device state (uptime, battery, connectivity)..." \
    "echo -e '\nUptime:' && uptime && echo -e '\nBattery:' && dumpsys battery && echo -e '\nNetwork:' && dumpsys connectivity" \
    "device_state.txt" \
    "silent"

    # ---------- NETWORK INFO (SILENT) ----------
    run_adb_command "Collecting network interface configuration (ifconfig / ip addr)..." \
    "ifconfig 2>/dev/null || ip addr show" \
    "network_info.txt" \
    "silent"

    # ---------- MAIN EXTRACTION COMMANDS ----------
    run_adb_command "Listing all apps you have accounts on..." \
    "dumpsys account | grep -i com.*$ -o | cut -d' ' -f1 | cut -d} -f1 | grep -v com$" \
    "registered.txt"

    run_adb_command "Listing all email addresses registered on the device..." \
    "dumpsys account | grep -E -o '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}' | sort -u" \
    "emails.txt"

    run_adb_command "Listing number of reboots..." \
    "settings list global | grep 'boot_count=' | cut -d= -f2 | head -n 1 | xargs echo 'Booted:' | sed 's/$/ times/g'" \
    "reboots.txt"

    run_adb_command "Listing every contact and phone number..." \
    "content query --uri content://contacts/phones/ --projection display_name:number | cut -f 3- -d ' '" \
    "numbers.txt"

    run_adb_command "Listing contact phone numbers..." \
    "content query --uri content://contacts/phones/" \
    "contacts.txt"

    run_adb_command "Dumping Call Log..." \
    "content query --uri content://call_log/calls" \
    "call_logs.txt"

    run_adb_command "Dumping SMS messages..." \
    "content query --uri content://sms/" \
    "sms.txt"

    run_adb_command "Listing all installed packages..." \
    "pm list packages" \
    "packages_all.txt"

    run_adb_command "Listing third-party installed packages..." \
    "pm list packages -3" \
    "packages_thirdparty.txt"

    run_adb_command "Listing all active services..." \
    "dumpsys -l" \
    "services.txt"

    # ---------- LOGCAT SNAPSHOT (SILENT) ----------
    run_adb_command "Capturing brief system log snapshot..." \
    "logcat -d -v time | head -n 1000" \
    "logcat_snapshot.txt" \
    "silent"

    # ---------- FULL BUGREPORT (BACKGROUND) ----------
    BUGREPORT_FILE="${OUTPUT_DIR}/bugreport_$(date +%Y%m%d_%H%M%S).zip"
    echo -e "${BLUE}[*] Generating full bugreport in the background...${NC}"
    echo -e "${YELLOW}[i] Bugreport may take several minutes. You can continue using the script.${NC}"

    (
        if adb shell 'command -v bugreportz' &> /dev/null; then
            adb bugreport "$BUGREPORT_FILE"
        else
            adb bugreport > "${BUGREPORT_FILE%.zip}.txt"
            BUGREPORT_FILE="${BUGREPORT_FILE%.zip}.txt"
        fi
        echo -e "${GREEN}[✓] Bugreport completed and saved to ${BUGREPORT_FILE}${NC}"
    ) &

    # ---------- SUMMARY REPORT ----------
    SCRIPT_END=$(date +%s)
    TOTAL_TIME=$((SCRIPT_END - SCRIPT_START))

    echo -e "\n${GREEN}[✓] All ADB data extraction commands executed successfully!${NC}"
    echo -e "${BLUE}Summary of extracted files:${NC}"
    echo -e "-------------------------------------------"
    ls -lh "$OUTPUT_DIR" | awk 'NR>1 {print $9, "\t", $5}'
    echo -e "-------------------------------------------"
    echo -e "${GREEN}Results saved in: ${OUTPUT_DIR}${NC}"
    echo -e "${GREEN}Total runtime (without waiting for bugreport): ${TOTAL_TIME}s${NC}\n"
    echo -e "${YELLOW}[i] Bugreport is running in the background and will save to the output directory once completed.${NC}\n"
}


secretCodes() {
    # -----------------------------------------------------------
    # Simple bash script that uses ADB to scan installed Android
    # packages and extract any secret dialer codes, logging them
    # with device info to a timestamped file.
    # -----------------------------------------------------------

    # -----------------------------------------------------------
    # Colors
    # -----------------------------------------------------------
    RED='\033[1;31m'      # Red
    GREEN='\033[0;32m'    # Green
    YELLOW='\033[1;33m'   # Yellow
    BLUE='\033[1;34m'     # Blue
    CYAN='\033[1;36m'     # Cyan
    PURPLE='\033[1;35m'   # Purple
    WHITE='\033[1;37m'    # White
    RESET='\033[0m'        # Reset

    # -----------------------------------------------------------
    # Trap Ctrl-C
    # -----------------------------------------------------------
    trap ctrl_c INT
    ctrl_c() {
        echo
        echo -e "${WHITE}Ctrl-C by user${RESET}"
        exit
    }

    # -----------------------------------------------------------
    # Timestamp & Output file
    # -----------------------------------------------------------
    timestamp=$(date +'%Y-%m-%d_%H:%M:%S')
    output_file="$PWD/Secret_Codes_${timestamp}.txt"

    # -----------------------------------------------------------
    # Blank line helpers
    # -----------------------------------------------------------
    space() { echo ""; }
    double_space() { echo -e "\n"; }

    # -----------------------------------------------------------
    # Device Info
    # -----------------------------------------------------------
    man=$(adb shell getprop | grep ro.product.manufacturer | tr -d '[]' | awk '{print $NF}')
    model=$(adb shell getprop ro.product.model)
    os_ver=$(adb shell getprop ro.build.version.release)

    # -----------------------------------------------------------
    # Colored Banner
    # -----------------------------------------------------------
    show_banner() {
        echo -e "${WHITE}============================================================${RESET}"
        echo -e "${CYAN}          ANDROID SECRET CODE EXTRACTION TOOL${RESET}"
        echo -e "${WHITE}============================================================${RESET}"
        echo -e "${WHITE} Manufacturer: ${CYAN}${man}${RESET}"
        echo -e "${WHITE} Model:        ${CYAN}${model}${RESET}"
        echo -e "${WHITE} OS Version:   ${CYAN}${os_ver}${RESET}"
        echo -e "${WHITE} Log File:     ${CYAN}${output_file}${RESET}"
        echo -e "${WHITE}============================================================${RESET}"
        echo
    }

    # -----------------------------------------------------------
    # FUNCTION:
    # Dump all android secret codes (GREEN on screen)
    # Rest of output is WHITE
    # -----------------------------------------------------------
    android_secret_code_dump() {

        package_name_trim=$(adb shell 'pm list packages -s -f' \
            | awk -F 'package:' '{print $2}' \
            | awk -F '=' '{print $2}')

        for pkg in ${package_name_trim}; do
            
            # package name shown in white
            echo -e "${WHITE}${pkg}${RESET}" | tee -a "${output_file}"

            adb shell pm dump "${pkg}" \
                | grep -E 'Scheme: "android_secret_code"|Authority: "[0-9].*"|Authority: "[A-Z].*"' \
                | while IFS= read -r line; do
                    
                    # print secret code lines in CYAN
                    echo -e "${GREEN}${line}${RESET}"

                    # write uncolored version to log file
                    echo "${line}" >> "${output_file}"
                done
        done
    }

    # -----------------------------------------------------------
    # Start Script
    # -----------------------------------------------------------
    show_banner

    echo -e "${WHITE}Dumping Android secret codes...${RESET}"
    android_secret_code_dump

    echo
    echo -e "${GREEN}✔ ${PURPLE}Output written to: ${CYAN}${output_file}${RESET}"
    echo
}

mkdir -p ${HOME}/.local/share/androforensic/ &>$LOGFILE
pushd ${HOME}/.local/share/androforensic/ &>$LOGFILE

banner
case $1 in
    airscope)
        airscope
        ;;
    dumpsys)
        dumpsys "$2"
        ;;
    extract)
        extract
        ;;
    secretCodes)
        secretCodes
        ;;
    *)
        STDERR
        ;;
esac

popd &>$LOGFILE
echo -en "\n[CREDITS] Douglas Habian\n    ╰───➤ original author of the scripts integrated in this module.\n"
